# 91. 解码方法
难度：中等   
题目地址：https://leetcode-cn.com/problems/decode-ways/   
完成时间：  2021/9/27   
# 题目
一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```
要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

+ "AAJF" ，将消息分组为 (1 1 10 6)
+ "KJF" ，将消息分组为 (11 10 6)   

注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

 

**示例 1：**
```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```
**示例 2：**
```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```
**示例 3：**
```
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
```
**示例 4：**
```
输入：s = "06"
输出：0
解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。
```

**提示：**

+ 1 <= s.length <= 100
+ s 只包含数字，并且可能包含前导零。


# 思路
本题是题目[639. 解码方法 II](./639.%20解码方法%20II.md)的前置题目。其力扣网址：https://leetcode-cn.com/problems/decode-ways-ii/     
   
总体思路：动态规划 + 简单模拟。

**过程：** 

设dp[i]表示前i个字符的解码方法数。

首先确定一个dp[0] = 1的边界条件。

然后找到状态转移方程：    
1. 使用一个字符：   dp[i] = dp[i - 1],      当 s[i] != 0
2. 使用两个字符：   dp[i] += dp[i - 2],     当 s[i - 2] \* 10 + s[i - 1] <= 26 

# 代码
java实现：   
```
class Solution {
    // 进阶题目：639. 解码方法 II
    public int numDecodings(String s) {
        int len = s.length();
        // dp[i]表示前i个字符的解码方法数
        int[] dp = new int[len + 1];
        // 边界条件：空字符可以有一种解码方法，即解码出一个空字符。
        dp[0] = 1;
        for (int i = 1; i <= len; i++) {
            int pre = s.charAt(i - 1) - '0';
            if (pre > 0) {
                dp[i] = dp[i - 1];
            }
            if (i <= 1) {
                continue;
            }
            int pre2 = s.charAt(i - 2) - '0';
            if (pre2 != 0 && pre2 * 10 + pre <= 26) {
                dp[i] += dp[i - 2];
            }
        }
        return dp[len];
    }
}
```
python实现：   
```
class Solution:
    # 进阶题目：639. 解码方法 II
    def numDecodings(self, s: str) -> int:
        N = len(s)
        # dp[i]表示前i个字符的解码方法数
        # 边界条件：空字符可以有一种解码方法，即解码出一个空字符。
        dp = [1] + [0] * N

        for i in range(1, N + 1):
            pre = int(s[i - 1])
            if pre != 0:
                dp[i] += dp[i - 1]
            if i <= 1:
                continue
            pre2 = int(s[i - 2])
            if pre2 != 0 and pre2 * 10 + pre <= 26:
                dp[i] += dp[i - 2]
        return dp[N]
```
# 其他



