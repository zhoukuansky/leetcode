# 861. 翻转矩阵后的得分
难度：简单、中等、困难   
题目地址：https://leetcode-cn.com/problems/score-after-flipping-matrix/    
完成时间：  2020/12/7   
# 题目
有一个二维矩阵 A 其中每个元素的值为 0 或 1 。

移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

返回尽可能高的分数。

**示例：**
```
输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
输出：39
解释：
转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
```

**提示：**

1. 1 <= A.length <= 20
2. 1 <= A[0].length <= 20
3. A[i][j] 是 0 或 1

# 思路
这道题的总体思路如下：
为使得最终结果最大，则矩阵的每一行的最左边的数都必须为 1。若不为1，则移动这一行。

当将每一行的最左边的数都变为 1 之后，就只能进行列翻转了。列翻转时，第一列已经全部为1。至于其他列，如果1的总和大于等于0的总和，就不用翻转，否则翻转。
# 代码
java实现：
```
//时间复杂度：O(mn)O(mn)，其中 mm 为矩阵行数，nn 为矩阵列数。
//空间复杂度：O(1)
class Solution {
    public int matrixScore(int[][] A) {
        int row = A.length;
        int line = A[0].length;
        int res = 0;
        //遍历顺序是一列一列的遍历，而非一行一行遍历
        //这里的n是2的n次方的意思
        for (int j = line - 1, n = 0; j >= 0; j--, n++) {
            //计数：每一列中有效1的数量
            int count = 0;
            //开始遍历每一列
            for (int i = 0; i < row; i++) {
                //如果元素所对应的行开头元素是1，则统计1
                if (A[i][0] == 1 && A[i][j] == 1){
                    count++;
                }
                //如果元素所对应的行开头元素是1，则统计0
                if (A[i][0] == 0 && A[i][j] == 0){
                    count++;
                }
            }
            res += Math.max(count, row - count) * Math.pow(2, n);
        }
        return res;
    }
}
```
python实现：
```
# 时间复杂度：O(mn)O(mn)，其中 mm 为矩阵行数，nn 为矩阵列数。
# 空间复杂度：O(1)
class Solution:
    def matrixScore(self, A: List[List[int]]) -> int:
        row, line = len(A), len(A[0])
        # 每行第一个数若是0，则将此行的所有0变1，1变0
        for i in range(row):
            if A[i][0] == 0:
                for j in range(line):
                    A[i][j] = A[i][j] ^ 1
        res = 0
        # zip能将对应列的元素打包成一个元组，返回的是一个迭代器
        # 这里先将A解压一层，变成一维
        for i in zip(*A):
            line -= 1
            res += (2 ** line) * max(i.count(1), i.count(0))
        return res
```
# 其他
可见，上述的java和python的思路是相同的。但是py的解法中由于有zip函数。所以，显示代码十分简单。这里记录一下zip函数。
```
zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。
```
```
>>> a = 5
>>> b = [3,4,5]
>>> c = [(3,4,5), (6,7,8)]
>>> d = [[(3,4,5),(6,7,8)]]
---
print(*a)  #结果会出现error
print(*b)
print(*c)
print(*d)
#输出分别为
Error
3 4 5
(3, 4, 5) (6, 7, 8)
[(3, 4, 5), (6, 7, 8)]
```

这儿必须得看懂“ * ”的意思，*号把所有操作数都打开了一层，二维列表变成了一维，三维变成了二维，而对int进行解压报错时。

在上面的题目中:
```
假设   A = [[1,1,0,0],[1,0,1,0],[1,1,0,0]]
则    list(zip(*zip(*A))) = [(1, 1, 0, 0), (1, 0, 1, 0), (1, 1, 0, 0)]
```
这里不太好理解，加油！